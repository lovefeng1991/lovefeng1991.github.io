<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随笔]]></title>
    <url>%2F2018%2F10%2F20%2Fessay%2F</url>
    <content type="text"><![CDATA[孤独一人。]]></content>
  </entry>
  <entry>
    <title><![CDATA[恭喜RNG夺冠！！！]]></title>
    <url>%2F2018%2F09%2F14%2Flpl-summer%2F</url>
    <content type="text"><![CDATA[LPL牛逼！RNG牛逼！UZI牛逼！]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP使用迭代器遍历文件]]></title>
    <url>%2F2018%2F09%2F01%2Fget-files%2F</url>
    <content type="text"><![CDATA[PHP标准库（SPL）是用于解决典型问题的一组接口与类的集合。 平时在写代码过程接触SPL比较少，最近在看Symfony源代码过程中，发现它在遍历文件过程中使用到了SPL中的迭代器，感觉挺厉害。 一般遍历文件会结合使用opendir函数和readdir函数，当然也可以使用glob函数，使用迭代器的情况比较少，下面直接上代码，看Symfony内是如何运用迭代器的。 1234567$files = iterator_to_array(new \RecursiveIteratorIterator( new \RecursiveCallbackFilterIterator( new \RecursiveDirectoryIterator(__DIR__, \FilesystemIterator::SKIP_DOTS | \FilesystemIterator::FOLLOW_SYMLINKS), function (\SplFileInfo $file) &#123; return '.' !== $file-&gt;getBasename()[0]; &#125; ), \RecursiveIteratorIterator::LEAVES_ONLY)); 这段代码会递归获取当前目录下所有的文件。是不是感觉很厉害！以后有时间好好研究下迭代器的使用，感觉能提高写代码的效率。]]></content>
      <categories>
        <category>php</category>
        <category>spl</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symfony路由机制-三]]></title>
    <url>%2F2018%2F08%2F29%2Fsymfony-routing-3%2F</url>
    <content type="text"><![CDATA[本文主要讲解Symfony3.4如何缓存路由。 上一篇文章提到匹配请求的匹配器实际是缓存路由后生成的PHP文件，而PHP文件中的代码主要由PhpMatcherDumper类中dump函数生成，这也是本篇文章分析的重点。 PhpMatcherDumper类的dump函数： 123456789101112131415161718192021222324252627282930313233343536373839public function dump(array $options = array())&#123; // 传入的$options会覆盖下面的值 $options = array_replace(array( // 匹配器类名 'class' =&gt; 'ProjectUrlMatcher', // 匹配器父类名 'base_class' =&gt; 'Symfony\\Component\\Routing\\Matcher\\UrlMatcher', ), $options); $interfaces = class_implements($options['base_class']); // 是否支持重定向 $supportsRedirections = isset($interfaces['Symfony\\Component\\Routing\\Matcher\\RedirectableUrlMatcherInterface']); return &lt;&lt;&lt;EOF&lt;?phpuse Symfony\Component\Routing\Exception\MethodNotAllowedException;use Symfony\Component\Routing\Exception\ResourceNotFoundException;use Symfony\Component\Routing\RequestContext;/*** This class has been auto-generated* by the Symfony Routing Component.*/class &#123;$options['class']&#125; extends &#123;$options['base_class']&#125;&#123;public function __construct(RequestContext \$context)&#123; // 初始化$context，这个值可用于condition配置项中 \$this-&gt;context = \$context;&#125;// 生成匹配器类match函数的代码&#123;$this-&gt;generateMatchMethod($supportsRedirections)&#125;&#125;EOF;&#125; \vendor\symfony\symfony\src\Symfony\Component\Routing\Matcher\Dumper\PhpMatcherDumper.php PhpMatcherDumper类的generateMatchMethod函数： 1234567891011121314151617181920212223242526private function generateMatchMethod($supportsRedirections)&#123; // 编译路由，生成代码 $code = rtrim($this-&gt;compileRoutes($this-&gt;getRoutes(), $supportsRedirections), "\n"); // match函数的代码 return &lt;&lt;&lt;EOFpublic function match(\$rawPathinfo)&#123; \$allow = array(); \$pathinfo = rawurldecode(\$rawPathinfo); \$trimmedPathinfo = rtrim(\$pathinfo, '/'); \$context = \$this-&gt;context; \$request = \$this-&gt;request ?: \$this-&gt;createRequest(\$pathinfo); \$requestMethod = \$canonicalMethod = \$context-&gt;getMethod(); if ('HEAD' === \$requestMethod) &#123; \$canonicalMethod = 'GET'; &#125;$code throw 0 &lt; count(\$allow) ? new MethodNotAllowedException(array_unique(\$allow)) : new ResourceNotFoundException();&#125;EOF;&#125; \vendor\symfony\symfony\src\Symfony\Component\Routing\Matcher\Dumper\PhpMatcherDumper.php PhpMatcherDumper类的compileRoutes函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243private function compileRoutes(RouteCollection $routes, $supportsRedirections)&#123; $fetchedHost = false; // 根据host正则对路由分组 $groups = $this-&gt;groupRoutesByHostRegex($routes); $code = ''; foreach ($groups as $collection) &#123; if (null !== $regex = $collection-&gt;getAttribute('host_regex')) &#123; // 在host正则不为空的情况下，需要获取请求对象中host的值 if (!$fetchedHost) &#123; // 这段代码只需要生成一次 $code .= " \$host = \$context-&gt;getHost();\n\n"; $fetchedHost = true; &#125; // 匹配$host的代码 $code .= sprintf(" if (preg_match(%s, \$host, \$hostMatches)) &#123;\n", var_export($regex, true)); &#125; // 构建静态前缀路由集合 $tree = $this-&gt;buildStaticPrefixCollection($collection); // 根据路由静态前缀分组，编译路由后生成代码 $groupCode = $this-&gt;compileStaticPrefixRoutes($tree, $supportsRedirections); if (null !== $regex) &#123; // 添加缩进 $groupCode = preg_replace('/^.&#123;2,&#125;$/m', ' $0', $groupCode); $code .= $groupCode; // 与前面host正则不为空对应，添加闭合标签&#125; $code .= " &#125;\n\n"; &#125; else &#123; $code .= $groupCode; &#125; &#125; // used to display the Welcome Page in apps that don't define a homepage $code .= " if ('/' === \$pathinfo &amp;&amp; !\$allow) &#123;\n"; $code .= " throw new Symfony\Component\Routing\Exception\NoConfigurationException();\n"; $code .= " &#125;\n"; return $code;&#125; 注意：在解析host配置项时，host配置项的值会被解析为字符串，因此host配置项需要使用正则表达式。host配置项使用场景可以用来区分桌面版和移动版页面，比如host: (www|m).pangpang.fun。 注意：正则表达式中m选项表示多行模式，^和$匹配每行的开头和结尾。 \vendor\symfony\symfony\src\Symfony\Component\Routing\Matcher\Dumper\PhpMatcherDumper.php groupRoutesByHostRegex函数会将host正则相同的路由分为同一组，同组路由具有连续性。在分组过程中，会编译路由。PhpMatcherDumper类的groupRoutesByHostRegex函数： 12345678910111213141516171819202122232425private function groupRoutesByHostRegex(RouteCollection $routes)&#123; // 路由组 $groups = new DumperCollection(); // 当前组 $currentGroup = new DumperCollection(); $currentGroup-&gt;setAttribute('host_regex', null); // 添加子组 $groups-&gt;add($currentGroup); foreach ($routes as $name =&gt; $route) &#123; // 编译路由，获取host模式串对应的正则表达式 $hostRegex = $route-&gt;compile()-&gt;getHostRegex(); // 在当前组host正则不相等情况下，会新增子路由组 if ($currentGroup-&gt;getAttribute('host_regex') !== $hostRegex) &#123; $currentGroup = new DumperCollection(); $currentGroup-&gt;setAttribute('host_regex', $hostRegex); $groups-&gt;add($currentGroup); &#125; // 添加DumperRoute $currentGroup-&gt;add(new DumperRoute($name, $route)); &#125; return $groups;&#125; 注意：host正则相同不代表host配置项的值相同，比如host: “{secondary}.pangpang.fun”,requirements: {secondary: www|m}与host: “{secondary}.pangpang.fun”编译生成的正则表达式完全不同。 \vendor\symfony\symfony\src\Symfony\Component\Routing\Matcher\Dumper\PhpMatcherDumper.php Route类的compile函数： 1234567891011public function compile()&#123; if (null !== $this-&gt;compiled) &#123; return $this-&gt;compiled; &#125; // 编译类，即RouteCompiler类 $class = $this-&gt;getOption('compiler_class'); return $this-&gt;compiled = $class::compile($this);&#125; \vendor\symfony\symfony\src\Symfony\Component\Routing\Route.php compile函数会编译host模式串和path模式串，结合其他配置项，比如defaults、requirements，生成正则表达式。RouteCompiler类的compile函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public static function compile(Route $route)&#123; $hostVariables = array(); $variables = array(); $hostRegex = null; $hostTokens = array(); if ('' !== $host = $route-&gt;getHost()) &#123; // 编译host模式串 $result = self::compilePattern($route, $host, true); // host模式串中的变量 $hostVariables = $result['variables']; $variables = $hostVariables; $hostTokens = $result['tokens']; // host模式串对应的正则表达式 $hostRegex = $result['regex']; &#125; // 获取path模式串 $path = $route-&gt;getPath(); // 编译path模式串 $result = self::compilePattern($route, $path, false); // 静态前缀 $staticPrefix = $result['staticPrefix']; // path模式串中的变量数组 $pathVariables = $result['variables']; foreach ($pathVariables as $pathParam) &#123; // path模式串中不能包含_fragment变量，也就是说_fragment不能在path配置项中使用， // 但能在defaults配置项中使用，虽然没啥作用，_fragment一般用于生成URL中 if ('_fragment' === $pathParam) &#123; throw new \InvalidArgumentException(sprintf('Route pattern "%s" cannot contain "_fragment" as a path parameter.', $route-&gt;getPath())); &#125; &#125; // 合并host模式串和path模式串的变量数组 $variables = array_merge($variables, $pathVariables); $tokens = $result['tokens']; // path模式串对应的正则表达式 $regex = $result['regex']; return new CompiledRoute( $staticPrefix, $regex, $tokens, $pathVariables, $hostRegex, $hostTokens, $hostVariables, array_unique($variables) );&#125; 注意：host模式串和path模式串能使用同一变量。 \vendor\symfony\symfony\src\Symfony\Component\Routing\RouteCompiler.php RouteCompiler类的compilePattern函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164private static function compilePattern(Route $route, $pattern, $isHost)&#123; $tokens = array(); $variables = array(); $matches = array(); $pos = 0; // 默认分隔符，编译host模式串时，分割符为.；编译path模式串时，分隔符为/ $defaultSeparator = $isHost ? '.' : '/'; // 模式串是否使用utf8字符集 $useUtf8 = preg_match('//u', $pattern); // 获取utf8选项 $needsUtf8 = $route-&gt;getOption('utf8'); if (!$needsUtf8 &amp;&amp; $useUtf8 &amp;&amp; preg_match('/[\x80-\xFF]/', $pattern)) &#123; $needsUtf8 = true; @trigger_error(sprintf('Using UTF-8 route patterns without setting the "utf8" option is deprecated since Symfony 3.2 and will throw a LogicException in 4.0. Turn on the "utf8" route option for pattern "%s".', $pattern), E_USER_DEPRECATED); &#125; if (!$useUtf8 &amp;&amp; $needsUtf8) &#123; throw new \LogicException(sprintf('Cannot mix UTF-8 requirements with non-UTF-8 pattern "%s".', $pattern)); &#125; // 获取由&#123;&#125;包围的变量，使用\w避免匹配&#123;和&#125;，防止大括号嵌套，比如&#123;foo&#123;bar&#125;&#125; preg_match_all('#\&#123;\w+\&#125;#', $pattern, $matches, PREG_OFFSET_CAPTURE | PREG_SET_ORDER); foreach ($matches as $match) &#123; // 获取变量名 $varName = substr($match[0][0], 1, -1); // 获取当前变量前面的静态文本 $precedingText = substr($pattern, $pos, $match[0][1] - $pos); // 更新$pos $pos = $match[0][1] + \strlen($match[0][0]); // 获取当前变量前面的静态字符 if (!\strlen($precedingText)) &#123; $precedingChar = ''; &#125; elseif ($useUtf8) &#123; // 使用u选项匹配utf8 preg_match('/.$/u', $precedingText, $precedingChar); $precedingChar = $precedingChar[0]; &#125; else &#123; $precedingChar = substr($precedingText, -1); &#125; // 是否为分隔符 $isSeparator = '' !== $precedingChar &amp;&amp; false !== strpos(static::SEPARATORS, $precedingChar); // A PCRE subpattern name must start with a non-digit. Also a PHP variable cannot start with a digit so the // variable would not be usable as a Controller action argument. // 变量名不能以数字开头 if (preg_match('/^\d/', $varName)) &#123; throw new \DomainException(sprintf('Variable name "%s" cannot start with a digit in route pattern "%s". Please use a different name.', $varName, $pattern)); &#125; // 不能重复使用变量名，比如path: /default/&#123;id&#125;/&#123;id&#125; if (\in_array($varName, $variables)) &#123; throw new \LogicException(sprintf('Route pattern "%s" cannot reference variable name "%s" more than once.', $pattern, $varName)); &#125; // 变量名长度不能超过32 if (\strlen($varName) &gt; self::VARIABLE_MAXIMUM_LENGTH) &#123; throw new \DomainException(sprintf('Variable name "%s" cannot be longer than %s characters in route pattern "%s". Please use a shorter name.', $varName, self::VARIABLE_MAXIMUM_LENGTH, $pattern)); &#125; if ($isSeparator &amp;&amp; $precedingText !== $precedingChar) &#123; // 比如path: /default/employees/&#123;id&#125; // 添加文本token，去掉末尾分隔符 $tokens[] = array('text', substr($precedingText, 0, -\strlen($precedingChar))); &#125; elseif (!$isSeparator &amp;&amp; \strlen($precedingText) &gt; 0) &#123; // 比如path: /default/test&#123;id&#125; $tokens[] = array('text', $precedingText); &#125; // 从requirements配置项获取变量名正则 $regexp = $route-&gt;getRequirement($varName); if (null === $regexp) &#123; $followingPattern = (string) substr($pattern, $pos); // Find the next static character after the variable that functions as a separator. By default, this separator and '/' // are disallowed for the variable. This default requirement makes sure that optional variables can be matched at all // and that the generating-matching-combination of URLs unambiguous, i.e. the params used for generating the URL are // the same that will be matched. Example: new Route('/&#123;page&#125;.&#123;_format&#125;', array('_format' =&gt; 'html')) // If &#123;page&#125; would also match the separating dot, &#123;_format&#125; would never match as &#123;page&#125; will eagerly consume everything. // Also even if &#123;_format&#125; was not optional the requirement prevents that &#123;page&#125; matches something that was originally // part of &#123;_format&#125; when generating the URL, e.g. _format = 'mobile.html'. $nextSeparator = self::findNextSeparator($followingPattern, $useUtf8); $regexp = sprintf( '[^%s%s]+', preg_quote($defaultSeparator, self::REGEX_DELIMITER), $defaultSeparator !== $nextSeparator &amp;&amp; '' !== $nextSeparator ? preg_quote($nextSeparator, self::REGEX_DELIMITER) : '' ); if (('' !== $nextSeparator &amp;&amp; !preg_match('#^\&#123;\w+\&#125;#', $followingPattern)) || '' === $followingPattern) &#123; // When we have a separator, which is disallowed for the variable, we can optimize the regex with a possessive // quantifier. This prevents useless backtracking of PCRE and improves performance by 20% for matching those patterns. // Given the above example, there is no point in backtracking into &#123;page&#125; (that forbids the dot) when a dot must follow // after it. This optimization cannot be applied when the next char is no real separator or when the next variable is // directly adjacent, e.g. '/&#123;x&#125;&#123;y&#125;'. $regexp .= '+'; &#125; &#125; else &#123; if (!preg_match('//u', $regexp)) &#123; // 变量名正则未使用utf8字符集 $useUtf8 = false; &#125; elseif (!$needsUtf8 &amp;&amp; preg_match('/[\x80-\xFF]|(?&lt;!\\\\)\\\\(?:\\\\\\\\)*+(?-i:X|[pP][\&#123;CLMNPSZ]|x\&#123;[A-Fa-f0-9]&#123;3&#125;)/', $regexp)) &#123; // 变量名正则使用utf8字符集，但未设置utf8选项 $needsUtf8 = true; @trigger_error(sprintf('Using UTF-8 route requirements without setting the "utf8" option is deprecated since Symfony 3.2 and will throw a LogicException in 4.0. Turn on the "utf8" route option for variable "%s" in pattern "%s".', $varName, $pattern), E_USER_DEPRECATED); &#125; if (!$useUtf8 &amp;&amp; $needsUtf8) &#123; // 变量名正则未使用utf8字符集，但却设置了utf8选项 throw new \LogicException(sprintf('Cannot mix UTF-8 requirement with non-UTF-8 charset for variable "%s" in pattern "%s".', $varName, $pattern)); &#125; &#125; // 添加变量token $tokens[] = array('variable', $isSeparator ? $precedingChar : '', $regexp, $varName); // 添加变量名 $variables[] = $varName; &#125; // 处理完所有变量后，还未到模式串结尾，那剩下的字符串肯定为文本token if ($pos &lt; \strlen($pattern)) &#123; // 添加文本token $tokens[] = array('text', substr($pattern, $pos)); &#125; // 找到第一个可选token，显然token必须为变量token，并且需要设置默认值，这里只考虑了path模式串 $firstOptional = PHP_INT_MAX; if (!$isHost) &#123; // 考虑path: /&#123;_locale&#125;/default/employees/&#123;id&#125;，假设变量_locale和id都设置了默认值， // 变量token(id)是第一个可选token，也就是可以不用传参数，/en/default/employees能正确匹配， // 而变量token(_locale)必须传参数，尽管设置了默认值，/default/employees/1无法正确匹配， // 也就是说寻找第一个可选token过程中，会考虑变量token的连续性 for ($i = \count($tokens) - 1; $i &gt;= 0; --$i) &#123; // 从后向前找 $token = $tokens[$i]; if ('variable' === $token[0] &amp;&amp; $route-&gt;hasDefault($token[3])) &#123; $firstOptional = $i; &#125; else &#123; break; &#125; &#125; &#125; $regexp = ''; for ($i = 0, $nbToken = \count($tokens); $i &lt; $nbToken; ++$i) &#123; // 计算正则表达式 $regexp .= self::computeRegexp($tokens, $i, $firstOptional); &#125; // 使用默认分隔符拼接出最终的正则表达式，对于host模式串，会添加i选项，即忽略大小写 $regexp = self::REGEX_DELIMITER.'^'.$regexp.'$'.self::REGEX_DELIMITER.'sD'.($isHost ? 'i' : ''); // 支持utf8匹配需要拼接u选项 if ($needsUtf8) &#123; $regexp .= 'u'; for ($i = 0, $nbToken = \count($tokens); $i &lt; $nbToken; ++$i) &#123; if ('variable' === $tokens[$i][0]) &#123; $tokens[$i][] = true; &#125; &#125; &#125; return array( 'staticPrefix' =&gt; self::determineStaticPrefix($route, $tokens), // 静态前缀 'regex' =&gt; $regexp, // 正则表达式 'tokens' =&gt; array_reverse($tokens), // tokens数组 'variables' =&gt; $variables, // 变量名 );&#125; 注意：options配置项似乎只有compiler_class和utf8选项有效。 \vendor\symfony\symfony\src\Symfony\Component\Routing\RouteCompiler.php RouteCompiler类的常量属性SEPARATORS定义了正则表达式可用的分隔符。 1const SEPARATORS = '/,;.:-_~+*=@|'; 注意：PHP正则表达式分隔符可以是任意非字母数字、非反斜线（\）、非空白字符。具体见http://php.net/manual/zh/regexp.reference.delimiters.php。 RouteCompiler类的常量属性REGEX_DELIMITER定义了默认分隔符。 1const REGEX_DELIMITER = '#'; RouteCompiler类的常量属性VARIABLE_MAXIMUM_LENGTH定义了变量的最大长度。 1const VARIABLE_MAXIMUM_LENGTH = 32; RouteCompiler类的findNextSeparator函数： 12345678910111213141516private static function findNextSeparator($pattern, $useUtf8)&#123; if ('' == $pattern) &#123; // return empty string if pattern is empty or false (false which can be returned by substr) return ''; &#125; // first remove all placeholders from the pattern so we can find the next real static character if ('' === $pattern = preg_replace('#\&#123;\w+\&#125;#', '', $pattern)) &#123; return ''; &#125; if ($useUtf8) &#123; preg_match('/^./u', $pattern, $pattern); &#125; return false !== strpos(static::SEPARATORS, $pattern[0]) ? $pattern[0] : '';&#125; computeRegexp函数用来转义文本token和计算可选token生成的正则表达式。RouteCompiler类的computeRegexp函数： 1234567891011121314151617181920212223242526272829private static function computeRegexp(array $tokens, $index, $firstOptional)&#123; $token = $tokens[$index]; if ('text' === $token[0]) &#123; // 转义文本token，除了转义特殊符号外额外需要转义#，因为#是生成最终正则表达式的默认分隔符 return preg_quote($token[1], self::REGEX_DELIMITER); &#125; else &#123; // 变量token，需要考虑可选token if (0 === $index &amp;&amp; 0 === $firstOptional) &#123; // 当仅有一个token并且为可选token的时候，分隔符是必需的，比如path: /&#123;test&#125;， // 可选token生成的正则表达式结尾多个? return sprintf('%s(?P&lt;%s&gt;%s)?', preg_quote($token[1], self::REGEX_DELIMITER), $token[3], $token[2]); &#125; else &#123; // 比如path: /default/employees/&#123;id&#125;.&#123;_format&#125;,defaults: &#123;_format: html&#125; $regexp = sprintf('%s(?P&lt;%s&gt;%s)', preg_quote($token[1], self::REGEX_DELIMITER), $token[3], $token[2]); if ($index &gt;= $firstOptional) &#123; $regexp = "(?:$regexp"; $nbTokens = \count($tokens); if ($nbTokens - 1 == $index) &#123; // 遍历到最后一个token时，需要保证所有可选token都能正确闭合，即保证(?:与)?成对出现 // 前面$firstOptional为0的时候，使用了%s(?P&lt;%s&gt;%s)?作为正则，这里拼接)?次数要减去1 $regexp .= str_repeat(')?', $nbTokens - $firstOptional - (0 === $firstOptional ? 1 : 0)); &#125; &#125; return $regexp; &#125; &#125;&#125; 注意：PHP中正则表达式的特殊字符有：.+*?[^]$(){}=!&lt;&gt;|:-。具体见http://php.net/manual/zh/function.preg-quote.php determineStaticPrefix函数确定路由的静态前缀，后面会利用它分组。RouteCompiler类的determineStaticPrefix函数： 1234567891011121314151617private static function determineStaticPrefix(Route $route, array $tokens)&#123; // 比如path: /&#123;_locale&#125;/default/about/&#123;id&#125;，返回空 if ('text' !== $tokens[0][0]) &#123; return ($route-&gt;hasDefault($tokens[0][3]) || '/' === $tokens[0][1]) ? '' : $tokens[0][1]; &#125; $prefix = $tokens[0][1]; if (isset($tokens[1][1]) &amp;&amp; '/' !== $tokens[1][1] &amp;&amp; false === $route-&gt;hasDefault($tokens[1][3])) &#123; // 比如path: /defalut/avatar.&#123;_format&#125;，返回/defalut/avatar. $prefix .= $tokens[1][1]; &#125; // 比如path: /defalut/avatar.&#123;_format&#125;,defaults: &#123;_format: jpg&#125;，返回/defalut/avatar return $prefix;&#125; PhpMatcherDumper类的buildStaticPrefixCollection函数： 12345678910111213141516private function buildStaticPrefixCollection(DumperCollection $collection)&#123; // 静态前缀路由集合 $prefixCollection = new StaticPrefixCollection(); foreach ($collection as $dumperRoute) &#123; // 获取静态前缀 $prefix = $dumperRoute-&gt;getRoute()-&gt;compile()-&gt;getStaticPrefix(); $prefixCollection-&gt;addRoute($prefix, $dumperRoute); &#125; // 优化分组 $prefixCollection-&gt;optimizeGroups(); return $prefixCollection;&#125; \vendor\symfony\symfony\src\Symfony\Component\Routing\Matcher\Dumper\PhpMatcherDumper.php StaticPrefixCollection类的addRoute函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243public function addRoute($prefix, $route)&#123; $prefix = '/' === $prefix ? $prefix : rtrim($prefix, '/'); // 防止添加不被接受的路由 $this-&gt;guardAgainstAddingNotAcceptedRoutes($prefix); if ($this-&gt;prefix === $prefix) &#123; // 路由集合的前缀与路由前缀严格相等的情况下，直接添加路由，并设置匹配开始位置，防止重复比较， // 注意这里的=== $this-&gt;items[] = array($prefix, $route); $this-&gt;matchStart = \count($this-&gt;items); return; &#125; // 不相等的情况下，需要遍历$items逐个比较，提取公共前缀，调整分组 foreach ($this-&gt;items as $i =&gt; $item) &#123; if ($i &lt; $this-&gt;matchStart) &#123; // 防止重复比较 continue; &#125; if ($item instanceof self &amp;&amp; $item-&gt;accepts($prefix)) &#123; // 递归调用，进入这里说明$item和$route有公共前缀 $item-&gt;addRoute($prefix, $route); return; &#125; // $item和$route组成子路由集合，成功返回新组，失败返回null $group = $this-&gt;groupWithItem($item, $prefix, $route); if ($group instanceof self) &#123; // 替换成子路由集合 $this-&gt;items[$i] = $group; return; &#125; &#125; // 遍历$items后无法组成新组，直接添加 $this-&gt;items[] = array($prefix, $route);&#125; 注意：父路由集合前缀为空，可以接受所有路由。 \vendor\symfony\symfony\src\Symfony\Component\Routing\Matcher\Dumper\StaticPrefixCollection.php StaticPrefixCollection类的guardAgainstAddingNotAcceptedRoutes函数： 12345678private function guardAgainstAddingNotAcceptedRoutes($prefix)&#123; if (!$this-&gt;accepts($prefix)) &#123; $message = sprintf('Could not add route with prefix %s to collection with prefix %s', $prefix, $this-&gt;prefix); throw new \LogicException($message); &#125;&#125; accepts函数规定了路由集合接受哪些路由。第一种情况，路由集合的前缀为空情况下，接受所有路由；第二种情况，路由集合的前缀是路由的前缀的前缀时，接受该路由。StaticPrefixCollection类的accepts函数： 1234private function accepts($prefix)&#123; return '' === $this-&gt;prefix || 0 === strpos($prefix, $this-&gt;prefix);&#125; StaticPrefixCollection的groupWithItem函数： 1234567891011121314151617181920212223242526272829private function groupWithItem($item, $prefix, $route)&#123; // 获取前缀 $itemPrefix = $item instanceof self ? $item-&gt;prefix : $item[0]; // 获取公共前缀 $commonPrefix = $this-&gt;detectCommonPrefix($prefix, $itemPrefix); if (!$commonPrefix) &#123; // 无公共前缀或者公共前缀比路由集合的前缀短，直接返回 return; &#125; // $item和$route组成子路由集合， $child = new self($commonPrefix); // 子路由集合添加$item if ($item instanceof self) &#123; // $item为路由集合 $child-&gt;items = array($item); &#125; else &#123; // $item为数组 $child-&gt;addRoute($item[0], $item[1]); &#125; // 子路由集合添加$route $child-&gt;addRoute($prefix, $route); return $child;&#125; StaticPrefixCollection的detectCommonPrefix函数： 123456789101112131415161718192021222324private function detectCommonPrefix($prefix, $anotherPrefix)&#123; $baseLength = \strlen($this-&gt;prefix); $commonLength = $baseLength; $end = min(\strlen($prefix), \strlen($anotherPrefix)); for ($i = $baseLength; $i &lt;= $end; ++$i) &#123; if (substr($prefix, 0, $i) !== substr($anotherPrefix, 0, $i)) &#123; break; &#125; $commonLength = $i; &#125; // 公共前缀 $commonPrefix = rtrim(substr($prefix, 0, $commonLength), '/'); // 公共前缀比路由集合的前缀长时，返回 if (\strlen($commonPrefix) &gt; $baseLength) &#123; return $commonPrefix; &#125; return false;&#125; PhpMatcherDumper类的compileStaticPrefixRoutes函数： 1234567891011121314151617181920212223242526272829303132private function compileStaticPrefixRoutes(StaticPrefixCollection $collection, $supportsRedirections, $ifOrElseIf = 'if')&#123; $code = ''; // 获取前缀 $prefix = $collection-&gt;getPrefix(); if (!empty($prefix) &amp;&amp; '/' !== $prefix) &#123; // 前缀不为空的情况下，先匹配前缀 $code .= sprintf(" %s (0 === strpos(\$pathinfo, %s)) &#123;\n", $ifOrElseIf, var_export($prefix, true)); &#125; $ifOrElseIf = 'if'; foreach ($collection-&gt;getItems() as $route) &#123; if ($route instanceof StaticPrefixCollection) &#123; // 递归调用 $code .= $this-&gt;compileStaticPrefixRoutes($route, $supportsRedirections, $ifOrElseIf); $ifOrElseIf = 'elseif'; &#125; else &#123; $code .= $this-&gt;compileRoute($route[1]-&gt;getRoute(), $route[1]-&gt;getName(), $supportsRedirections, $prefix)."\n"; $ifOrElseIf = 'if'; &#125; &#125; if (!empty($prefix) &amp;&amp; '/' !== $prefix) &#123; $code .= " &#125;\n\n"; // apply extra indention at each line (except empty ones) $code = preg_replace('/^.&#123;2,&#125;$/m', ' $0', $code); &#125; return $code;&#125; 一般情况下，文件系统的路径中带有尾斜杠代表目录（/home/lovefeng1991/log/），反之代表文件（/home/lovefeng1991/log）。而浏览器会把这两种情况按相同URL路径处理，比如https://example.com/foo/和https://example.com/foo会按同一URL处理。Symfony使用重定向的方法来处理这种逻辑，但仅在处理GET和HEAD请求。具体见https://symfony.com/doc/3.4/routing.html#redirecting-urls-with-trailing-slashes。 路由路径 请求路径为/foo 请求路径为/foo/ /foo 匹配成功，返回200状态码 匹配失败，返回404状态码 /foo/ 301重定向到/foo/ 匹配成功，返回200状态码 PhpMatcherDumper类的compileRoute函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186private function compileRoute(Route $route, $name, $supportsRedirections, $parentPrefix = null)&#123; $code = ''; // 已经编译过的路由 $compiledRoute = $route-&gt;compile(); $conditions = array(); // 是否有尾斜杠 $hasTrailingSlash = false; // path是否匹配 $matches = false; // host是否匹配 $hostMatches = false; // 获取路由methods配置项的值 $methods = $route-&gt;getMethods(); // 是否支持尾斜杠 $supportsTrailingSlash = $supportsRedirections &amp;&amp; (!$methods || \in_array('GET', $methods)); // 获取path正则 $regex = $compiledRoute-&gt;getRegex(); // 下面这个正则用来匹配正则表示式，捕获的内容会被分组到url中，比如#^\d+$#，$m['url']的值为\d+ if (!\count($compiledRoute-&gt;getPathVariables()) &amp;&amp; false !== preg_match('#^(.)\^(?P&lt;url&gt;.*?)\$\1#'.('u' === substr($regex, -1) ? 'u' : ''), $regex, $m)) &#123; // path中不包含变量 if ($supportsTrailingSlash &amp;&amp; '/' === substr($m['url'], -1)) &#123; // 去掉尾斜杠 $conditions[] = sprintf('%s === $trimmedPathinfo', var_export(rtrim(str_replace('\\', '', $m['url']), '/'), true)); $hasTrailingSlash = true; &#125; else &#123; $conditions[] = sprintf('%s === $pathinfo', var_export(str_replace('\\', '', $m['url']), true)); &#125; &#125; else &#123; // path中包含变量 if ($compiledRoute-&gt;getStaticPrefix() &amp;&amp; $compiledRoute-&gt;getStaticPrefix() !== $parentPrefix) &#123; // 父前缀已经编译过，忽略父前缀 $conditions[] = sprintf('0 === strpos($pathinfo, %s)', var_export($compiledRoute-&gt;getStaticPrefix(), true)); &#125; if ($supportsTrailingSlash &amp;&amp; $pos = strpos($regex, '/$')) &#123; // /后拼接?表示尾斜杠可选 $regex = substr($regex, 0, $pos).'/?$'.substr($regex, $pos + 2); $hasTrailingSlash = true; &#125; $conditions[] = sprintf('preg_match(%s, $pathinfo, $matches)', var_export($regex, true)); $matches = true; &#125; if ($compiledRoute-&gt;getHostVariables()) &#123; // host中包含变量 $hostMatches = true; &#125; if ($route-&gt;getCondition()) &#123; // 编译condition配置项 $conditions[] = $this-&gt;getExpressionLanguage()-&gt;compile($route-&gt;getCondition(), array('context', 'request')); &#125; // 拼接条件代码，主要有三部分组成，前缀，path正则和condition配置项 $conditions = implode(' &amp;&amp; ', $conditions); $code .= &lt;&lt;&lt;EOF // $name if ($conditions) &#123;EOF; $gotoname = 'not_'.preg_replace('/[^A-Za-z0-9_]/', '', $name); // 12表示3个缩进，以4个空格为单位 $retOffset = 12 + \strlen($code); if ($matches || $hostMatches) &#123; $vars = array(); if ($hostMatches) &#123; $vars[] = '$hostMatches'; &#125; if ($matches) &#123; $vars[] = '$matches'; &#125; $vars[] = "array('_route' =&gt; '$name')"; $code .= sprintf( " \$ret = \$this-&gt;mergeDefaults(array_replace(%s), %s);\n", implode(', ', $vars), str_replace("\n", '', var_export($route-&gt;getDefaults(), true)) ); &#125; elseif ($route-&gt;getDefaults()) &#123; // 路由有默认值 $code .= sprintf(" \$ret = %s;\n", str_replace("\n", '', var_export(array_replace($route-&gt;getDefaults(), array('_route' =&gt; $name)), true))); &#125; else &#123; // 路由无默认值，因为未设置controller配置项；在设置controller配置项的情况下，会有默认配置项_controller $code .= sprintf(" \$ret = array('_route' =&gt; '%s');\n", $name); &#125; // path正则有尾斜杠 if ($hasTrailingSlash) &#123; $code .= &lt;&lt;&lt;EOF if ('/' === substr(\$pathinfo, -1)) &#123; // 什么都不用做 &#125; elseif ('GET' !== \$canonicalMethod) &#123; // 前面在请求方法为HEAD时，$canonicalMethod会设置为GET，保证在HEAD请求下处理尾斜杠 goto $gotoname; &#125; else &#123; // 301重定向 return array_replace(\$ret, \$this-&gt;redirect(\$rawPathinfo.'/', '$name')); &#125;EOF; &#125; if ($methods) &#123; $methodVariable = \in_array('GET', $methods) ? '$canonicalMethod' : '$requestMethod'; // 拼接methods配置项的值 $methods = implode("', '", $methods); &#125; // 获取schemes if ($schemes = $route-&gt;getSchemes()) &#123; if (!$supportsRedirections) &#123; throw new \LogicException('The "schemes" requirement is only supported for URL matchers that implement RedirectableUrlMatcherInterface.'); &#125; $schemes = str_replace("\n", '', var_export(array_flip($schemes), true)); if ($methods) &#123; $code .= &lt;&lt;&lt;EOF \$requiredSchemes = $schemes; \$hasRequiredScheme = isset(\$requiredSchemes[\$context-&gt;getScheme()]); if (!in_array($methodVariable, array('$methods'))) &#123; if (\$hasRequiredScheme) &#123; \$allow = array_merge(\$allow, array('$methods')); &#125; // method未匹配时，直接跳出 goto $gotoname; &#125; if (!\$hasRequiredScheme) &#123; if ('GET' !== \$canonicalMethod) &#123; goto $gotoname; &#125; // 在scheme未匹配，请求方法为GET和HEAD请求时，会发生301重定向 return array_replace(\$ret, \$this-&gt;redirect(\$rawPathinfo, '$name', key(\$requiredSchemes))); &#125;EOF; &#125; else &#123; $code .= &lt;&lt;&lt;EOF \$requiredSchemes = $schemes; if (!isset(\$requiredSchemes[\$context-&gt;getScheme()])) &#123; if ('GET' !== \$canonicalMethod) &#123; goto $gotoname; &#125; // 与上面类似 return array_replace(\$ret, \$this-&gt;redirect(\$rawPathinfo, '$name', key(\$requiredSchemes))); &#125;EOF; &#125; &#125; elseif ($methods) &#123; $code .= &lt;&lt;&lt;EOF if (!in_array($methodVariable, array('$methods'))) &#123; // method未匹配时，直接跳出 \$allow = array_merge(\$allow, array('$methods')); goto $gotoname; &#125;EOF; &#125; if ($hasTrailingSlash || $schemes || $methods) &#123; $code .= " return \$ret;\n"; &#125; else &#123; // 将"$ret ="替换为"return" $code = substr_replace($code, 'return', $retOffset, 6); &#125; $code .= " &#125;\n"; if ($hasTrailingSlash || $schemes || $methods) &#123; $code .= " $gotoname:\n"; &#125; return $code;&#125; 注意：路由在不设置配置项controller的情况下，不会影响路由的缓存。Symfony在kernel.request事件分发完成后，会去解析请求对象attributes中的_controller值，如果未设置的话，会抛出NotFoundHttpException异常。 UrlMatcher类的mergeDefaults函数 1234567891011protected function mergeDefaults($params, $defaults)&#123; foreach ($params as $key =&gt; $value) &#123; // 过滤掉数字键值 if (!\is_int($key)) &#123; $defaults[$key] = $value; &#125; &#125; return $defaults;&#125; \vendor\symfony\symfony\src\Symfony\Component\Routing\Matcher\UrlMatcher.php 未完待续]]></content>
      <categories>
        <category>symfony</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>symfony</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symfony路由机制-二]]></title>
    <url>%2F2018%2F08%2F12%2Fsymfony-routing-2%2F</url>
    <content type="text"><![CDATA[本文主要讲解Symfony3.4加载路由配置文件并将它解析为RouteCollection对象。 订阅事件router_listener服务通过配置kernel.event_subscriber标签来订阅事件。 12345678910&lt;service id="router_listener" class="Symfony\Component\HttpKernel\EventListener\RouterListener"&gt; &lt;tag name="kernel.event_subscriber" /&gt; &lt;tag name="monolog.logger" channel="request" /&gt; &lt;argument type="service" id="router" /&gt; &lt;argument type="service" id="request_stack" /&gt; &lt;argument type="service" id="router.request_context" on-invalid="ignore" /&gt; &lt;argument type="service" id="logger" on-invalid="ignore" /&gt; &lt;argument&gt;%kernel.project_dir%&lt;/argument&gt; &lt;argument&gt;%kernel.debug%&lt;/argument&gt;&lt;/service&gt; 下面简单介绍每个节点的含义： 第一个tag节点表示事件订阅。 第二个tag节点表示日志级别。 其余argument节点表示服务实例化时所需的参数。 详细分析会在依赖注入组件的文章中。 \vendor\symfony\symfony\src\Symfony\Bundle\FrameworkBundle\Resources\config\routing.xml 容器编译在容器编译的过程中，会调用所有Bundle的DependencyInjection\Compiler目录下以Pass结尾的类中的process函数，其中不同类具有不同的职责。RegisterListenersPass.php负责事件订阅部分，它的process函数会获取所有配置了kernel.event_listener和kernel.event_subscriber标签的服务，具有kernel.event_subscriber标签的服务会调用该服务的getSubscribedEvents方法获取服务订阅的事件。 注意：自定义服务，这里指事件订阅器，在配置了kernel.event_subscriber标签的情况下，必须实现EventSubscriberInterface接口的getSubscribedEvents方法。 RegisterListenersPass类的process函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public function process(ContainerBuilder $container)&#123; // 检查是否有事件分发服务，即event_dispatcher服务 if (!$container-&gt;hasDefinition($this-&gt;dispatcherService) &amp;&amp; !$container-&gt;hasAlias($this-&gt;dispatcherService)) &#123; return; &#125; // 获取事件分发服务 $definition = $container-&gt;findDefinition($this-&gt;dispatcherService); // 找到配置kernel.event_listener标签的所有服务 foreach ($container-&gt;findTaggedServiceIds($this-&gt;listenerTag, true) as $id =&gt; $events) &#123; foreach ($events as $event) &#123; // 优先级属性（可选），默认值为0 $priority = isset($event['priority']) ? $event['priority'] : 0; // 事件属性（必选），表示订阅的事件 if (!isset($event['event'])) &#123; throw new InvalidArgumentException(sprintf('Service "%s" must define the "event" attribute on "%s" tags.', $id, $this-&gt;listenerTag)); &#125; // 方法属性（可选），回调函数，对于kernel.request事件，默认值为onKernelRequest if (!isset($event['method'])) &#123; // 单词首字母大写 $event['method'] = 'on'.preg_replace_callback(array( '/(?&lt;=\b)[a-z]/i', // 匹配单词的首字母 '/[^a-z0-9]/i', // 匹配字符串中除字母和数字之外的字符 ), function ($matches) &#123; return strtoupper($matches[0]); &#125;, $event['event']); // 替换字符串中非字母和数字的字符为空 $event['method'] = preg_replace('/[^a-z0-9]/i', '', $event['method']); &#125; // 事件分发服务添加回调函数 $definition-&gt;addMethodCall('addListener', array($event['event'], array(new ServiceClosureArgument(new Reference($id)), $event['method']), $priority)); // FrameworkBundle在build的时候添加了5个hotPathEvents，分别是kernel.request， // kernel.controller，kernel.controller_arguments，kernel_response，kernel.finish_request if (isset($this-&gt;hotPathEvents[$event['event']])) &#123; // 为服务添加container.hot_path标签，由ResolveHotPathPass.php的process函数处理 $container-&gt;getDefinition($id)-&gt;addTag($this-&gt;hotPathTagName); &#125; &#125; &#125; $extractingDispatcher = new ExtractingEventDispatcher(); // 找到配置kernel.event_subscriber标签的所有服务 foreach ($container-&gt;findTaggedServiceIds($this-&gt;subscriberTag, true) as $id =&gt; $attributes) &#123; // 获取服务定义 $def = $container-&gt;getDefinition($id); // 获取类名 $class = $def-&gt;getClass(); // 获取反射类 if (!$r = $container-&gt;getReflectionClass($class)) &#123; throw new InvalidArgumentException(sprintf('Class "%s" used for service "%s" cannot be found.', $class, $id)); &#125; // 事件订阅器必须实现EventSubscriberInterface接口 if (!$r-&gt;isSubclassOf(EventSubscriberInterface::class)) &#123; throw new InvalidArgumentException(sprintf('Service "%s" must implement interface "%s".', $id, EventSubscriberInterface::class)); &#125; // 获取类名 $class = $r-&gt;name; ExtractingEventDispatcher::$subscriber = $class; // 添加订阅者，调用getSubscribedEvents方法返回订阅的事件 $extractingDispatcher-&gt;addSubscriber($extractingDispatcher); // 遍历监听器 foreach ($extractingDispatcher-&gt;listeners as $args) &#123; // 和上面类似 $args[1] = array(new ServiceClosureArgument(new Reference($id)), $args[1]); // 添加回调 $definition-&gt;addMethodCall('addListener', $args); // 和上面类似 if (isset($this-&gt;hotPathEvents[$args[0]])) &#123; $container-&gt;getDefinition($id)-&gt;addTag('container.hot_path'); &#125; &#125; $extractingDispatcher-&gt;listeners = array(); &#125;&#125; /(?&lt;=\b)[a-z]/i用到了正则表达式中的零宽断言，可以参考这篇教程：正则表达式30分钟入门教程。 \vendor\symfony\symfony\src\Symfony\Component\EventDispatcher\DependencyInjection\RegisterListenersPass.php RouterListener类的getSubscribedEvents函数： 12345678public static function getSubscribedEvents()&#123; return array( KernelEvents::REQUEST =&gt; array(array('onKernelRequest', 32)), KernelEvents::FINISH_REQUEST =&gt; array(array('onKernelFinishRequest', 0)), KernelEvents::EXCEPTION =&gt; array('onKernelException', -64), );&#125; 显然，router_listener服务通过getSubscribedEvents函数订阅了kernel.request、kernel.finish_request、kernel.exception这3个事件。也就是说,配置1&lt;tag name="kernel.event_subscriber" /&gt; 与配置123&lt;tag name="kernel.event_listener" priority="32" event="kernel.request" method="onKernelRequest" /&gt;&lt;tag name="kernel.event_listener" event="kernel.finish_request" method="onKernelFinishRequest" /&gt;&lt;tag name="kernel.event_listener" priority="-64" event="kernel.exception" method="onKernelException" /&gt; 效果一样，可见kernel.event_subscriber配置方法比kernel.event_listener灵活的多。 详细分析会在之后事件分发组件的文章中。 服务订阅事件可以配置kernel.event_listener标签和kernel.event_subscriber标签，只需要定义一个标签即可。 注意：当两个标签配置同一个事件的时候，后者并不会覆盖前者，会在事件分发的时候，执行两遍。 \vendor\symfony\symfony\src\Symfony\Component\HttpKernel\EventListener\RouterListener.php 处理请求Symfony3.4在处理请求时，会分发kernel.request事件。在分发过程中，router_listener服务会调用回调函数onKernelRequest。 123$event = new GetResponseEvent($this, $request, $type);// 分发kernel.request事件$this-&gt;dispatcher-&gt;dispatch(KernelEvents::REQUEST, $event); \vendor\symfony\symfony\src\Symfony\Component\HttpKernel\HttpKernel.php RouterListener类的onKernelRequest函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public function onKernelRequest(GetResponseEvent $event)&#123; // 获取请求对象 $request = $event-&gt;getRequest(); // 设置当前请求 $this-&gt;setCurrentRequest($request); if ($request-&gt;attributes-&gt;has('_controller')) &#123; // 路由匹配已经完成。如果一个事件订阅两次，这里会提前返回，避免无效工作 return; &#125; try &#123; // 调用匹配器来匹配请求 if ($this-&gt;matcher instanceof RequestMatcherInterface) &#123; $parameters = $this-&gt;matcher-&gt;matchRequest($request); &#125; else &#123; $parameters = $this-&gt;matcher-&gt;match($request-&gt;getPathInfo()); &#125; if (null !== $this-&gt;logger) &#123; $this-&gt;logger-&gt;info('Matched route "&#123;route&#125;".', array( 'route' =&gt; isset($parameters['_route']) ? $parameters['_route'] : 'n/a', 'route_parameters' =&gt; $parameters, 'request_uri' =&gt; $request-&gt;getUri(), 'method' =&gt; $request-&gt;getMethod(), )); &#125; // 参数添加到请求对象中 $request-&gt;attributes-&gt;add($parameters); unset($parameters['_route'], $parameters['_controller']); // 请求对象设置路由参数 $request-&gt;attributes-&gt;set('_route_params', $parameters); &#125; catch (ResourceNotFoundException $e) &#123; $message = sprintf('No route found for "%s %s"', $request-&gt;getMethod(), $request-&gt;getPathInfo()); if ($referer = $request-&gt;headers-&gt;get('referer')) &#123; $message .= sprintf(' (from "%s")', $referer); &#125; throw new NotFoundHttpException($message, $e); &#125; catch (MethodNotAllowedException $e) &#123; $message = sprintf('No route found for "%s %s": Method Not Allowed (Allow: %s)', $request-&gt;getMethod(), $request-&gt;getPathInfo(), implode(', ', $e-&gt;getAllowedMethods())); throw new MethodNotAllowedHttpException($e-&gt;getAllowedMethods(), $message, $e); &#125;&#125; \vendor\symfony\symfony\src\Symfony\Component\HttpKernel\EventListener\RouterListener.php 匹配请求Router类的matchRequest函数： 123456789101112public function matchRequest(Request $request)&#123; // 通过缓存路由后得到的匹配器，才是真正用于匹配请求的匹配器 $matcher = $this-&gt;getMatcher(); if (!$matcher instanceof RequestMatcherInterface) &#123; // fallback to the default UrlMatcherInterface return $matcher-&gt;match($request-&gt;getPathInfo()); &#125; // 匹配请求 return $matcher-&gt;matchRequest($request);&#125; 该函数获取真正匹配请求的匹配器。 \vendor\symfony\symfony\src\Symfony\Component\Routing\Router.php 匹配器Router类的getMatcher函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public function getMatcher()&#123; if (null !== $this-&gt;matcher) &#123; return $this-&gt;matcher; &#125; if (null === $this-&gt;options['cache_dir'] || null === $this-&gt;options['matcher_cache_class']) &#123; $this-&gt;matcher = new $this-&gt;options['matcher_class']($this-&gt;getRouteCollection(), $this-&gt;context); if (method_exists($this-&gt;matcher, 'addExpressionLanguageProvider')) &#123; foreach ($this-&gt;expressionLanguageProviders as $provider) &#123; $this-&gt;matcher-&gt;addExpressionLanguageProvider($provider); &#125; &#125; return $this-&gt;matcher; &#125; $cache = $this-&gt;getConfigCacheFactory()-&gt;cache($this-&gt;options['cache_dir'].'/'.$this-&gt;options['matcher_cache_class'].'.php', function (ConfigCacheInterface $cache) &#123; // 获取匹配器Dumper实例 $dumper = $this-&gt;getMatcherDumperInstance(); if (method_exists($dumper, 'addExpressionLanguageProvider')) &#123; foreach ($this-&gt;expressionLanguageProviders as $provider) &#123; $dumper-&gt;addExpressionLanguageProvider($provider); &#125; &#125; $options = array( // 匹配器类名 'class' =&gt; $this-&gt;options['matcher_cache_class'], // 匹配器父类名 'base_class' =&gt; $this-&gt;options['matcher_base_class'], ); // 缓存路由 $cache-&gt;write($dumper-&gt;dump($options), $this-&gt;getRouteCollection()-&gt;getResources()); &#125; ); if (!class_exists($this-&gt;options['matcher_cache_class'], false)) &#123; require_once $cache-&gt;getPath(); &#125; // 真正匹配器 return $this-&gt;matcher = new $this-&gt;options['matcher_cache_class']($this-&gt;context);&#125; \vendor\symfony\symfony\src\Symfony\Component\Routing\Router.php 匹配器DumperRouter类的getMatcherDumperInstance函数： 1234protected function getMatcherDumperInstance()&#123; return new $this-&gt;options['matcher_dumper_class']($this-&gt;getRouteCollection());&#125; matcher_dumper_class：Symfony\Component\Routing\Matcher\Dumper\PhpMatcherDumper \vendor\symfony\symfony\src\Symfony\Component\Routing\Router.php 该函数使用解析路由配置获得的RouteCollection对象实例化PhpMatcherDumper类。见下面配置。 12345678910111213&lt;parameters&gt;PhpMatcherDumper &lt;parameter key="router.options.generator_class"&gt;Symfony\Component\Routing\Generator\UrlGenerator&lt;/parameter&gt; &lt;parameter key="router.options.generator_base_class"&gt;Symfony\Component\Routing\Generator\UrlGenerator&lt;/parameter&gt; &lt;parameter key="router.options.generator_dumper_class"&gt;Symfony\Component\Routing\Generator\Dumper\PhpGeneratorDumper&lt;/parameter&gt; &lt;parameter key="router.options.matcher_class"&gt;Symfony\Bundle\FrameworkBundle\Routing\RedirectableUrlMatcher&lt;/parameter&gt; &lt;parameter key="router.options.matcher_base_class"&gt;Symfony\Bundle\FrameworkBundle\Routing\RedirectableUrlMatcher&lt;/parameter&gt; &lt;parameter key="router.options.matcher_dumper_class"&gt;Symfony\Component\Routing\Matcher\Dumper\PhpMatcherDumper&lt;/parameter&gt; &lt;parameter key="router.options.matcher.cache_class"&gt;%router.cache_class_prefix%UrlMatcher&lt;/parameter&gt; &lt;parameter key="router.options.generator.cache_class"&gt;%router.cache_class_prefix%UrlGenerator&lt;/parameter&gt; &lt;parameter key="router.request_context.host"&gt;localhost&lt;/parameter&gt; &lt;parameter key="router.request_context.scheme"&gt;http&lt;/parameter&gt; &lt;parameter key="router.request_context.base_url"&gt;&lt;/parameter&gt;&lt;/parameters&gt; \vendor\symfony\symfony\src\Symfony\Bundle\FrameworkBundle\Resources\config\routing.xml 路由集合Router类的getRouteCollection函数： 12345678910111213public function getRouteCollection()&#123; if (null === $this-&gt;collection) &#123; // 调用routing.loader服务加载路由资源 $this-&gt;collection = $this-&gt;container-&gt;get('routing.loader')-&gt;load($this-&gt;resource, $this-&gt;options['resource_type']); // 解析参数，解析配置中%包围的参数 $this-&gt;resolveParameters($this-&gt;collection); // 添加资源 $this-&gt;collection-&gt;addResource(new ContainerParametersResource($this-&gt;collectedParameters)); &#125; return $this-&gt;collection;&#125; \vendor\symfony\symfony\src\Symfony\Bundle\FrameworkBundle\Routing\Router.php $this-&gt;resource即routing_dev.yml。见下面配置。 12345framework: router: resource: '%kernel.project_dir%/app/config/routing_dev.yml' strict_requirements: true profiler: &#123; only_exceptions: false &#125; \app\config\config_dev.yml router.loader服务router.loader服务会在容器编译过程中生成文件getRouting_LoaderService.php。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?phpuse Symfony\Component\DependencyInjection\Argument\RewindableGenerator;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Config\\Loader\\LoaderInterface.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Config\\Loader\\Loader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Config\\Loader\\FileLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Routing\\Loader\\XmlFileLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Routing\\Loader\\YamlFileLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Routing\\Loader\\PhpFileLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Routing\\Loader\\GlobFileLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Routing\\Loader\\DirectoryLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Routing\\Loader\\ObjectRouteLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Routing\\Loader\\DependencyInjection\\ServiceRouterLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Routing\\Loader\\AnnotationClassLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Bundle\\FrameworkBundle\\Routing\\AnnotatedRouteControllerLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Routing\\Loader\\AnnotationFileLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Routing\\Loader\\AnnotationDirectoryLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Config\\Loader\\LoaderResolverInterface.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Config\\Loader\\LoaderResolver.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Config\\Loader\\DelegatingLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Bundle\\FrameworkBundle\\Routing\\DelegatingLoader.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Config\\FileLocatorInterface.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\Config\\FileLocator.php&apos;;include_once $this-&gt;targetDirs[3].&apos;\\vendor\\symfony\\symfony\\src\\Symfony\\Component\\HttpKernel\\Config\\FileLocator.php&apos;;// file_locator服务实例化$a = $&#123;($_ = isset($this-&gt;services[&apos;file_locator&apos;]) ? $this-&gt;services[&apos;file_locator&apos;] : $this-&gt;services[&apos;file_locator&apos;] = new \Symfony\Component\HttpKernel\Config\FileLocator($&#123;($_ = isset($this-&gt;services[&apos;kernel&apos;]) ? $this-&gt;services[&apos;kernel&apos;] : $this-&gt;get(&apos;kernel&apos;, 1)) &amp;&amp; false ?: &apos;_&apos;&#125;, ($this-&gt;targetDirs[3].&apos;\\app/Resources&apos;), array(0 =&gt; ($this-&gt;targetDirs[3].&apos;\\app&apos;)))) &amp;&amp; false ?: &apos;_&apos;&#125;;// annotation_reader服务实例化$b = $&#123;($_ = isset($this-&gt;services[&apos;annotation_reader&apos;]) ? $this-&gt;services[&apos;annotation_reader&apos;] : $this-&gt;getAnnotationReaderService()) &amp;&amp; false ?: &apos;_&apos;&#125;;$c = new \Symfony\Bundle\FrameworkBundle\Routing\AnnotatedRouteControllerLoader($b);// 加载器解析器$d = new \Symfony\Component\Config\Loader\LoaderResolver();// xml文件加载器$d-&gt;addLoader(new \Symfony\Component\Routing\Loader\XmlFileLoader($a));// yaml文件加载器$d-&gt;addLoader(new \Symfony\Component\Routing\Loader\YamlFileLoader($a));// php文件加载器$d-&gt;addLoader(new \Symfony\Component\Routing\Loader\PhpFileLoader($a));// glob文件加载器$d-&gt;addLoader(new \Symfony\Component\Routing\Loader\GlobFileLoader($a));// 目录加载器$d-&gt;addLoader(new \Symfony\Component\Routing\Loader\DirectoryLoader($a));$d-&gt;addLoader(new \Symfony\Component\Routing\Loader\DependencyInjection\ServiceRouterLoader($this));$d-&gt;addLoader($c);// annotation目录加载器$d-&gt;addLoader(new \Symfony\Component\Routing\Loader\AnnotationDirectoryLoader($a, $c));// annotation文件加载器$d-&gt;addLoader(new \Symfony\Component\Routing\Loader\AnnotationFileLoader($a, $c));return $this-&gt;services[&apos;routing.loader&apos;] = new \Symfony\Bundle\FrameworkBundle\Routing\DelegatingLoader($&#123;($_ = isset($this-&gt;services[&apos;controller_name_converter&apos;]) ? $this-&gt;services[&apos;controller_name_converter&apos;] : $this-&gt;services[&apos;controller_name_converter&apos;] = new \Symfony\Bundle\FrameworkBundle\Controller\ControllerNameParser($&#123;($_ = isset($this-&gt;services[&apos;kernel&apos;]) ? $this-&gt;services[&apos;kernel&apos;] : $this-&gt;get(&apos;kernel&apos;, 1)) &amp;&amp; false ?: &apos;_&apos;&#125;)) &amp;&amp; false ?: &apos;_&apos;&#125;, $d); routing.loader即DelegatingLoader，DelegatingLoader字面意思为委托加载器，它不具有加载资源的功能，但会利用LoaderResolver来获取加载资源的加载器。routing.loader实例化过程中LoaderResolver会添加9种加载器，因此Symfony3.4支持多种格式的路由配置，比如yaml、xml、php、annotation。 注意：有些加载器实例化的时候需要file_locator服务，这个服务会定位资源的位置。 加载路由资源DelegatingLoader类的load函数： 12345678910111213141516171819202122232425262728293031323334public function load($resource, $type = null)&#123; if ($this-&gt;loading) &#123; throw new FileLoaderLoadException($resource, null, null, null, $type); &#125; // 资源正在加载 $this-&gt;loading = true; try &#123; // 调用父类load函数 $collection = parent::load($resource, $type); &#125; finally &#123; $this-&gt;loading = false; &#125; foreach ($collection-&gt;all() as $route) &#123; // 不解析无效的值 if (!\is_string($controller = $route-&gt;getDefault('_controller')) || !$controller) &#123; continue; &#125; try &#123; // 解析控制器，EmployeesBundle:Default:employees将被解析为EmployeesBundle\Controller\DefaultController::employeesAction $controller = $this-&gt;parser-&gt;parse($controller); &#125; catch (\InvalidArgumentException $e) &#123; // 注意这里当controller的值不合理时，Symfony虽然会抛出异常，但没处理 &#125; // 替换为完整的控制器 $route-&gt;setDefault('_controller', $controller); &#125; return $collection;&#125; \vendor\symfony\symfony\src\Symfony\Bundle\FrameworkBundle\Routing\DelegatingLoader.php DelegatingLoader类的load函数： 12345678910public function load($resource, $type = null)&#123; // 调用LoaderResolver解析资源，确定加载器 if (false === $loader = $this-&gt;resolver-&gt;resolve($resource, $type)) &#123; throw new FileLoaderLoadException($resource, null, null, null, $type); &#125; // 加载资源 return $loader-&gt;load($resource, $type);&#125; \vendor\symfony\symfony\src\Symfony\Component\Config\Loader\DelegatingLoader.php LoaderResolver类的resolve函数： 12345678910public function resolve($resource, $type = null)&#123; foreach ($this-&gt;loaders as $loader) &#123; if ($loader-&gt;supports($resource, $type)) &#123; return $loader; &#125; &#125; return false;&#125; LoaderResolver会遍历9种加载器，通过调用supports方法来判断将会使用的加载器。 \vendor\symfony\symfony\src\Symfony\Component\Config\Loader\LoaderResolver.php 比如YamlFileLoader类的supports函数： 1234public function supports($resource, $type = null)&#123; return \is_string($resource) &amp;&amp; \in_array(pathinfo($resource, PATHINFO_EXTENSION), array('yml', 'yaml'), true) &amp;&amp; (!$type || 'yaml' === $type);&#125; \vendor\symfony\symfony\src\Symfony\Component\Routing\Loader\YamlFileLoader.php routing_dev.yml配置如下。 1234567891011121314_wdt: resource: '@WebProfilerBundle/Resources/config/routing/wdt.xml' prefix: /_wdt_profiler: resource: '@WebProfilerBundle/Resources/config/routing/profiler.xml' prefix: /_profiler_errors: resource: '@TwigBundle/Resources/config/routing/errors.xml' prefix: /_error_main: resource: routing.yml routing.yml一般为主路由配置，Symfony3.4通过加载它去加载自定义Bundle中的路由资源。FileLocator会在以下3个路径中寻找routing.yml文件。 routing_dev.yml所在目录，一般为\app\config \app\Resources（全局资源存放位置） \app（前面都找不到的话，在这个目录下找） 注意：按顺序解析，只会解析一个。 \app\config\routing_dev.yml 上面路径的配置见下面。 12345678&lt;service id="file_locator" class="Symfony\Component\HttpKernel\Config\FileLocator"&gt; &lt;argument type="service" id="kernel" /&gt; &lt;argument&gt;%kernel.root_dir%/Resources&lt;/argument&gt; &lt;argument type="collection"&gt; &lt;argument&gt;%kernel.root_dir%&lt;/argument&gt; &lt;/argument&gt;&lt;/service&gt;&lt;service id="Symfony\Component\HttpKernel\Config\FileLocator" alias="file_locator" /&gt; \vendor\symfony\symfony\src\Symfony\Bundle\FrameworkBundle\Resources\config\services.xml 这里只分析Yaml文件加载器，其余加载器类似。YamlFileLoader类的load函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public function load($file, $type = null)&#123; // 定位器检查文件是否存在，将别名地址（以@开头）转换为绝对地址，在路径中寻找相对地址 $path = $this-&gt;locator-&gt;locate($file); // 必须为本地文件 if (!stream_is_local($path)) &#123; throw new \InvalidArgumentException(sprintf('This is not a local file "%s".', $path)); &#125; if (!file_exists($path)) &#123; throw new \InvalidArgumentException(sprintf('File "%s" not found.', $path)); &#125; if (null === $this-&gt;yamlParser) &#123; // Yaml解析器 $this-&gt;yamlParser = new YamlParser(); &#125; // 设置自定义错误处理函数，解析yaml文件出错时会用到这个错误处理函数 $prevErrorHandler = set_error_handler(function ($level, $message, $script, $line) use ($file, &amp;$prevErrorHandler) &#123; $message = E_USER_DEPRECATED === $level ? preg_replace('/ on line \d+/', ' in "'.$file.'"$0', $message) : $message; return $prevErrorHandler ? $prevErrorHandler($level, $message, $script, $line) : false; &#125;); try &#123; // 解析yaml文件，返回PHP数组 $parsedConfig = $this-&gt;yamlParser-&gt;parseFile($path); &#125; catch (ParseException $e) &#123; throw new \InvalidArgumentException(sprintf('The file "%s" does not contain valid YAML.', $path), 0, $e); &#125; finally &#123; // 还原错误处理函数 restore_error_handler(); &#125; // 初始化RouteCollection类 $collection = new RouteCollection(); // 添加资源 $collection-&gt;addResource(new FileResource($path)); // yaml文件为空 if (null === $parsedConfig) &#123; return $collection; &#125; // 非数组 if (!\is_array($parsedConfig)) &#123; throw new \InvalidArgumentException(sprintf('The file "%s" must contain a YAML array.', $path)); &#125; foreach ($parsedConfig as $name =&gt; $config) &#123; // 验证路由配置是否合法 $this-&gt;validate($config, $name, $path); if (isset($config['resource'])) &#123; // 解析导入 $this-&gt;parseImport($collection, $config, $path, $file); &#125; else &#123; // 解析路由 $this-&gt;parseRoute($collection, $name, $config, $path); &#125; &#125; return $collection;&#125; \vendor\symfony\symfony\src\Symfony\Component\Routing\Loader\YamlFileLoader.php YamlFileLoader类中有个私有静态属性$availableKeys，定义了路由配置的所有选项。 1234private static $availableKeys = array( 'resource', 'type', 'prefix', 'path', 'host', 'schemes', 'methods', 'defaults', 'requirements', 'options', 'condition', 'controller',); \vendor\symfony\symfony\src\Symfony\Component\Routing\Loader\YamlFileLoader.php 配置项具体含义如下： resource：资源路径，相对地址或者绝对地址或者别名地址（以@开头） type：类型，比如annotation、glob prefix：前缀，与resource搭配使用 path：路由路径 host：主机，比如blog.pangpang.fun schemes：表示URI schemes，常见的比如http、https methods：请求类型，比如get、post defaults：默认值，与path项搭配使用，其中_controller非常重要 requirements：一般为正则表达式 options：选项，比如{‘utf8’: true}表示支持utf8 condition：条件，使用The Expression Syntax controller：映射的控制器，比如EmployeesBundle:Default:employees 注意：schemes表示URI schemes，具体见https://en.wikipedia.org/wiki/Uniform_Resource_Identifier#Generic_syntax。常见schemes有：http、https、ftp、mailto，对于web应用来说，scheme一般表示http和https。 validate函数用来验证路由配置是否合法，可以看到路由配置需要遵守的约定。YamlFileLoader类的validate函数： 123456789101112131415161718192021222324252627282930313233343536373839protected function validate($config, $name, $path)&#123; // 配置必须为数组 if (!\is_array($config)) &#123; throw new \InvalidArgumentException(sprintf('The definition of "%s" in "%s" must be a YAML array.', $name, $path)); &#125; // 配置项必须在$availableKeys数组中 if ($extraKeys = array_diff(array_keys($config), self::$availableKeys)) &#123; throw new \InvalidArgumentException(sprintf( 'The routing file "%s" contains unsupported keys for "%s": "%s". Expected one of: "%s".', $path, $name, implode('", "', $extraKeys), implode('", "', self::$availableKeys) )); &#125; // 配置项resource和path不能同时出现 if (isset($config['resource']) &amp;&amp; isset($config['path'])) &#123; throw new \InvalidArgumentException(sprintf( 'The routing file "%s" must not specify both the "resource" key and the "path" key for "%s". Choose between an import and a route definition.', $path, $name )); &#125; // 配置项type必须与resource同时出现 if (!isset($config['resource']) &amp;&amp; isset($config['type'])) &#123; throw new \InvalidArgumentException(sprintf( 'The "type" key for the route definition "%s" in "%s" is unsupported. It is only available for imports in combination with the "resource" key.', $name, $path )); &#125; // 配置项resource和path至少出现一个 if (!isset($config['resource']) &amp;&amp; !isset($config['path'])) &#123; throw new \InvalidArgumentException(sprintf( 'You must define a "path" for the route "%s" in file "%s".', $name, $path )); &#125; // 配置项controller和defaults中的_controller不能同时出现 if (isset($config['controller']) &amp;&amp; isset($config['defaults']['_controller'])) &#123; throw new \InvalidArgumentException(sprintf('The routing file "%s" must not specify both the "controller" key and the defaults key "_controller" for "%s".', $path, $name)); &#125;&#125; \vendor\symfony\symfony\src\Symfony\Component\Routing\Loader\YamlFileLoader.php YamlFileLoader类的parseRoute函数： 12345678910111213141516171819202122protected function parseRoute(RouteCollection $collection, $name, array $config, $path)&#123; // 获取各个配置项的值，没设置的话，设置默认值 $defaults = isset($config['defaults']) ? $config['defaults'] : array(); $requirements = isset($config['requirements']) ? $config['requirements'] : array(); $options = isset($config['options']) ? $config['options'] : array(); $host = isset($config['host']) ? $config['host'] : ''; $schemes = isset($config['schemes']) ? $config['schemes'] : array(); $methods = isset($config['methods']) ? $config['methods'] : array(); $condition = isset($config['condition']) ? $config['condition'] : null; // controller配置项的值会保存到defaults配置项中的_controller if (isset($config['controller'])) &#123; $defaults['_controller'] = $config['controller']; &#125; // 实例化路由 $route = new Route($config['path'], $defaults, $requirements, $options, $host, $schemes, $methods, $condition); // 添加路由，重复定义的情况，会按先后顺序只保留后者 $collection-&gt;add($name, $route);&#125; 注意：在配置了path的情况下，path、defaults、requirements、options、host、schemes、methods、condition、controller这9个配置项有效。注意：实例化Route过程中，会为options添加默认值{‘compiler_class’: ‘Symfony\Component\Routing\RouteCompiler’}。 \vendor\symfony\symfony\src\Symfony\Component\Routing\Loader\YamlFileLoader.php YamlFileLoader类的parseImport函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758protected function parseImport(RouteCollection $collection, array $config, $path, $file)&#123; // 获取各个配置项的值，没设置的话，设置默认值 $type = isset($config['type']) ? $config['type'] : null; $prefix = isset($config['prefix']) ? $config['prefix'] : ''; $defaults = isset($config['defaults']) ? $config['defaults'] : array(); $requirements = isset($config['requirements']) ? $config['requirements'] : array(); $options = isset($config['options']) ? $config['options'] : array(); $host = isset($config['host']) ? $config['host'] : null; $condition = isset($config['condition']) ? $config['condition'] : null; $schemes = isset($config['schemes']) ? $config['schemes'] : null; $methods = isset($config['methods']) ? $config['methods'] : null; // 同parseRoute函数 if (isset($config['controller'])) &#123; $defaults['_controller'] = $config['controller']; &#125; // 设置当前目录，主要用于FileLocator中 $this-&gt;setCurrentDir(\dirname($path)); // 导入路由资源，返回的是子路由集合 $imported = $this-&gt;import($config['resource'], $type, false, $file); if (!\is_array($imported)) &#123; $imported = array($imported); &#125; foreach ($imported as $subCollection) &#123; // 添加前缀，作用于path $subCollection-&gt;addPrefix($prefix); if (null !== $host) &#123; // 设置主机，会覆盖$subCollection中的host $subCollection-&gt;setHost($host); &#125; if (null !== $condition) &#123; // 设置条件，会覆盖$subCollection中的condition $subCollection-&gt;setCondition($condition); &#125; if (null !== $schemes) &#123; // 设置协议，会覆盖$subCollection中的schemes $subCollection-&gt;setSchemes($schemes); &#125; if (null !== $methods) &#123; // 设置请求方法，会覆盖$subCollection中的methods $subCollection-&gt;setMethods($methods); &#125; // 添加默认 $subCollection-&gt;addDefaults($defaults); // 添加条件 $subCollection-&gt;addRequirements($requirements); // 添加选项 $subCollection-&gt;addOptions($options); // 添加子集合 $collection-&gt;addCollection($subCollection); &#125;&#125; 注意：在配置了resource的情况下，resource、type、prefix、defaults、requirements、options、host、condition、schemes、methods这10个配置项有效。 \vendor\symfony\symfony\src\Symfony\Component\Routing\Loader\YamlFileLoader.php RouteCollection类的addPrefix函数： 1234567891011121314151617public function addPrefix($prefix, array $defaults = array(), array $requirements = array())&#123; // 去掉prefix首尾空格字符和/ $prefix = trim(trim($prefix), '/'); // 为空直接返回。 if ('' === $prefix) &#123; return; &#125; foreach ($this-&gt;routes as $route) &#123; // path前拼接prefix，重新设置path $route-&gt;setPath('/'.$prefix.$route-&gt;getPath()); $route-&gt;addDefaults($defaults); $route-&gt;addRequirements($requirements); &#125;&#125; \vendor\symfony\symfony\src\Symfony\Component\Routing\RouteCollection.php 这个函数比较简单，作用就是遍历集合中所有路由，在path前面添加前缀。RouteCollection类中并没有setPrefix函数，因此prefix需要配合resource配置项使用，为resource内所有路由添加前缀。配置了resource的情况下，由于resource的配置非常灵活，这里需要调用父类的import函数确定具体的加载器并重复上面步骤。FileLoader类的import函数： 1234567891011121314151617181920212223public function import($resource, $type = null, $ignoreErrors = false, $sourceResource = null)&#123; // 通过正则匹配来判断是否使用glob函数，第一次看到strcspn函数的使用 if (\is_string($resource) &amp;&amp; \strlen($resource) !== $i = strcspn($resource, '*?&#123;[')) &#123; $ret = array(); // 是否是子路径 $isSubpath = 0 !== $i &amp;&amp; false !== strpos(substr($resource, 0, $i), '/'); // 这个函数就不分析了，主要是使用PHP系统函数glob函数获取符合条件的文件并返回 foreach ($this-&gt;glob($resource, false, $_, $ignoreErrors || !$isSubpath) as $path =&gt; $info) &#123; // 导入文件 if (null !== $res = $this-&gt;doImport($path, $type, $ignoreErrors, $sourceResource)) &#123; $ret[] = $res; &#125; $isSubpath = true; &#125; if ($isSubpath) &#123; return isset($ret[1]) ? $ret : (isset($ret[0]) ? $ret[0] : null); &#125; &#125; return $this-&gt;doImport($resource, $type, $ignoreErrors, $sourceResource);&#125; \vendor\symfony\symfony\src\Symfony\Component\Config\Loader\FileLoader.php 在什么情况下会使用到glob函数呢？看下面的例子。 123456789101112131415161718192021# 这是\app\config\routing.yml文件中的配置app: resource: '@AppBundle/Controller/' type: annotation# 将会解析@EmployeesBundle/Resources/config/routing下所有yaml文件employees: resource: '@EmployeesBundle/Resources/config/routing/*.yml'# 将会解析@EmployeesBundle/Resources/config/routing下所有yaml和xml文件employees: resource: '@EmployeesBundle/Resources/config/routing/*.&#123;yml,xml&#125;'# 将会解析@EmployeesBundle/Resources/config/routing下ess.yml和rss.yml文件employees: resource: '@EmployeesBundle/Resources/config/routing/[er]ss.yml'# 将会解析@EmployeesBundle/Resources/config/routing下ess.yml、eas.yml等文件# 注意?与正则表达式中?含义不一样，这里的?表示除/以外的一个字符employees: resource: '@EmployeesBundle/Resources/config/routing/e?s.yml' glob模式匹配的规则可以看glob函数下的第一个用户评论。 FileLoader类的doImport函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private function doImport($resource, $type = null, $ignoreErrors = false, $sourceResource = null)&#123; try &#123; // 调用LoaderResolver解析资源，结合type项的值确定具体使用的加载器，前面已经分析过 $loader = $this-&gt;resolve($resource, $type); if ($loader instanceof self &amp;&amp; null !== $this-&gt;currentDir) &#123; // 定位文件 $resource = $loader-&gt;getLocator()-&gt;locate($resource, $this-&gt;currentDir, false); &#125; $resources = \is_array($resource) ? $resource : array($resource); for ($i = 0; $i &lt; $resourcesCount = \count($resources); ++$i) &#123; if (isset(self::$loading[$resources[$i]])) &#123; if ($i == $resourcesCount - 1) &#123; // 循环导入异常 throw new FileLoaderImportCircularReferenceException(array_keys(self::$loading)); &#125; &#125; else &#123; // 当找到多个文件时，只解析第一个 $resource = $resources[$i]; break; &#125; &#125; self::$loading[$resource] = true; try &#123; // 加载资源，重复上面步骤，返回RouteCollection $ret = $loader-&gt;load($resource, $type); &#125; finally &#123; unset(self::$loading[$resource]); &#125; return $ret; &#125; catch (FileLoaderImportCircularReferenceException $e) &#123; throw $e; &#125; catch (\Exception $e) &#123; if (!$ignoreErrors) &#123; // prevent embedded imports from nesting multiple exceptions if ($e instanceof FileLoaderLoadException) &#123; throw $e; &#125; throw new FileLoaderLoadException($resource, $sourceResource, null, $e, $type); &#125; &#125;&#125; 解析控制器返回看加载路由资源，DelegatingLoader类的load函数在加载完路由配置后，需要进一步解析controller配置项，比如EmployeesBundle:Default:employees将被解析为EmployeesBundle\Controller\DefaultController::employeesAction。controller配置一般分为3个部分，Bundle、Controller和Action，使用:连接。ControllerNameParser类的parse函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public function parse($controller)&#123; // 以:为分隔符分割字符串 $parts = explode(':', $controller); // controller需要定义三个部分，Bundle、Controller和Action if (3 !== \count($parts) || \in_array('', $parts, true)) &#123; throw new \InvalidArgumentException(sprintf('The "%s" controller is not a valid "a:b:c" controller string.', $controller)); &#125; $originalController = $controller; list($bundle, $controller, $action) = $parts; $controller = str_replace('/', '\\', $controller); $bundles = array(); try &#123; // 获取Bundle $allBundles = $this-&gt;kernel-&gt;getBundle($bundle, false, true); &#125; catch (\InvalidArgumentException $e) &#123; $message = sprintf( 'The "%s" (from the _controller value "%s") does not exist or is not enabled in your kernel!', $bundle, $originalController ); if ($alternative = $this-&gt;findAlternative($bundle)) &#123; $message .= sprintf(' Did you mean "%s:%s:%s"?', $alternative, $controller, $action); &#125; throw new \InvalidArgumentException($message, 0, $e); &#125; if (!\is_array($allBundles)) &#123; // happens when HttpKernel is version 4+ $allBundles = array($allBundles); &#125; foreach ($allBundles as $b) &#123; // 拼接出完整的控制器 $try = $b-&gt;getNamespace().'\\Controller\\'.$controller.'Controller'; if (class_exists($try)) &#123; // 控制器存在直接返回 return $try.'::'.$action.'Action'; &#125; $bundles[] = $b-&gt;getName(); $msg = sprintf('The _controller value "%s:%s:%s" maps to a "%s" class, but this class was not found. Create this class or check the spelling of the class and its namespace.', $bundle, $controller, $action, $try); &#125; if (\count($bundles) &gt; 1) &#123; $msg = sprintf('Unable to find controller "%s:%s" in bundles %s.', $bundle, $controller, implode(', ', $bundles)); &#125; throw new \InvalidArgumentException($msg);&#125; 注意：自定义Bundle必须在AppKernel中注册，即在registerBundles函数中声明，否则上面函数中getBundle函数会找不到指定的Bundle。 \vendor\symfony\symfony\src\Symfony\Bundle\FrameworkBundle\Controller\ControllerNameParser.php 解析参数返回看路由集合，在加载完路由配置后，需要解析其中的参数。Router中类的resolveParameters函数： 123456789101112131415161718192021222324252627282930313233343536private function resolveParameters(RouteCollection $collection)&#123; // foreach ($collection as $route) &#123; // 解析defaults配置项 foreach ($route-&gt;getDefaults() as $name =&gt; $value) &#123; $route-&gt;setDefault($name, $this-&gt;resolve($value)); &#125; // 解析requirements配置项 foreach ($route-&gt;getRequirements() as $name =&gt; $value) &#123; $route-&gt;setRequirement($name, $this-&gt;resolve($value)); &#125; // 解析path配置项 $route-&gt;setPath($this-&gt;resolve($route-&gt;getPath())); // 解析host配置项 $route-&gt;setHost($this-&gt;resolve($route-&gt;getHost())); $schemes = array(); // 解析schemes配置项 foreach ($route-&gt;getSchemes() as $scheme) &#123; $schemes = array_merge($schemes, explode('|', $this-&gt;resolve($scheme))); &#125; $route-&gt;setSchemes($schemes); $methods = array(); // 解析methods配置项 foreach ($route-&gt;getMethods() as $method) &#123; $methods = array_merge($methods, explode('|', $this-&gt;resolve($method))); &#125; $route-&gt;setMethods($methods); // 解析condition配置项 $route-&gt;setCondition($this-&gt;resolve($route-&gt;getCondition())); &#125;&#125; 注意：可以看出，schemes和methods有两种配置方法，以yaml格式为例，有methods: [get, post]和methods: get|post两种配置方法。 \vendor\symfony\symfony\src\Symfony\Bundle\FrameworkBundle\Routing\Router.php resolve函数比较简单，主要解析由%包含的参数。Router类的resolve函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private function resolve($value)&#123; // 参数为数组的情况，递归解析 if (\is_array($value)) &#123; foreach ($value as $key =&gt; $val) &#123; $value[$key] = $this-&gt;resolve($val); &#125; return $value; &#125; // 参数不是字符串，直接返回 if (!\is_string($value)) &#123; return $value; &#125; // 容器 $container = $this-&gt;container; // 解析%包围的参数，比如%host% $escapedValue = preg_replace_callback('/%%|%([^%\s]++)%/', function ($match) use ($container, $value) &#123; // skip %% if (!isset($match[1])) &#123; return '%%'; &#125; if (preg_match('/^env\(\w+\)$/', $match[1])) &#123; throw new RuntimeException(sprintf('Using "%%%s%%" is not allowed in routing configuration.', $match[1])); &#125; // 获取参数实际值 $resolved = $container-&gt;getParameter($match[1]); if (\is_string($resolved) || is_numeric($resolved)) &#123; $this-&gt;collectedParameters[$match[1]] = $resolved; return (string) $resolved; &#125; throw new RuntimeException(sprintf( 'The container parameter "%s", used in the route configuration value "%s", '. 'must be a string or numeric, but it is of type %s.', $match[1], $value, \gettype($resolved) ) ); &#125;, $value); return str_replace('%%', '%', $escapedValue);&#125; 注意：一般自定义参数会在\app\config\parameters.yml和\app\config\services.yml中定义，定义后可以在其他地方以%key%的形式调用。其中\app\config\parameters.yml包含全局自定义参数，\app\config\services.yml包含服务自定义参数。 \vendor\symfony\symfony\src\Symfony\Bundle\FrameworkBundle\Routing\Router.php 至此，所有路由配置解析完毕，返回RouteCollection对象。RouteCollection类中有两个属性，routes属性保存所有的路由信息，是一个Route对象数组，resources保存已经解析过的资源文件，是一个实现了ResourceInterface接口的对象数组，比如FileResource、DirectoryResource。 ResourceInterface：Symfony\Component\Config\Resource\ResourceInterface]]></content>
      <categories>
        <category>symfony</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>symfony</tag>
        <tag>路由</tag>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symfony源码分析]]></title>
    <url>%2F2018%2F08%2F12%2Fsymfony%2F</url>
    <content type="text"><![CDATA[前言 Symfony框架]]></content>
      <categories>
        <category>symfony</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>symfony</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symfony路由机制-一]]></title>
    <url>%2F2018%2F08%2F07%2Fsymfony-routing%2F</url>
    <content type="text"><![CDATA[路由组件是Symfony框架的核心组件之一，主要有如下功能： 根据URL或者Console命令匹配已配置的路由，映射到具体的控制器中 在模板（比如Twig）和控制器中生成优雅的URL 加载Bundle中路由资源（比如routing.yml） Symfony在首次请求时会缓存路由，在测试环境下，会在/var/cache/dev下生成appProjectContainerUrlMatcher.php，之后的请求会直接调用该文件中的match方法，加快路由匹配速度。 比如在/app/config/routing.yml中，有如下配置1234567default_page: path: /default/page/&#123;page&#125; controller: 'DemoBundle:Default:page' defaults: page: 1 requirements: page: '\d+' 会生成下面的代码1234// default_pageif (0 === strpos($pathinfo, '/default/page') &amp;&amp; preg_match('#^/default/page(?:/(?P&lt;page&gt;\\d+))?$#sD', $pathinfo, $matches)) &#123; return $this-&gt;mergeDefaults(array_replace($matches, array('_route' =&gt; 'default_page')), array ( 'page' =&gt; 1, '_controller' =&gt; 'DemoBundle\\Controller\\DefaultController::pageAction',));&#125; 后面文章会详细介绍具体细节。]]></content>
      <categories>
        <category>symfony</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>symfony</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode859. 亲密字符串]]></title>
    <url>%2F2018%2F08%2F06%2Fbuddy-string%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/buddy-strings Code12345678910111213141516171819202122232425262728293031323334353637383940414243function buddyStrings(string $a, string $b) :bool &#123; $aLength = strlen($a); $bLength = strlen($b); if ($aLength != $bLength) &#123; return false; &#125; if ($aLength &lt; 2) &#123; return false; &#125; $canChange = false; $hashMap = []; $diff = 0; $indexOne = -1; $indexTwo = -1; for ($i = 0; $i &lt; $aLength; $i++) &#123; if (isset($hashMap[$a[$i]])) &#123; ++$hashMap[$a[$i]]; &#125; else &#123; $hashMap[$a[$i]] = 1; &#125; if ($hashMap[$a[$i]] &gt;= 2) &#123; $canChange = true; &#125; if ($a[$i] != $b[$i]) &#123; $diff++; if ($indexOne == -1) &#123; $indexOne = $i; &#125; elseif ($indexTwo == -1) &#123; $indexTwo = $i; &#125; &#125; &#125; return ($diff == 0 &amp;&amp; $canChange) || ($diff == 2 &amp;&amp; $a[$indexOne] == $b[$indexTwo] &amp;&amp; $a[$indexTwo] == $b[$indexOne]);&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode686. 重复叠加字符串匹配]]></title>
    <url>%2F2018%2F08%2F05%2Frepeated-string-match%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/repeated-string-match Code1234567891011121314function repeatedStringMatch(string $a, string $b) :int &#123; $aLength = strlen($a); $bLength = strlen($b); for ($i = 0; $i &lt; $aLength; $i++) &#123; for ($j = 0; $j &lt; $bLength &amp;&amp; $a[($i + $j) % $aLength] == $b[$j]; $j++); if ($j == $bLength) &#123; return intdiv($i + $j - 1, $aLength) + 1; &#125; &#125; return -1;&#125; Leetcode28的变形。]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode443. 压缩字符串]]></title>
    <url>%2F2018%2F08%2F05%2Fstring-compression%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/string-compression Code123456789101112131415161718192021222324252627282930function compress(array $chars) :int &#123; $count = count($chars); $index = 0; $i = 0; while ($i &lt; $count) &#123; $currentChar = $chars[$i]; $n = 0; while ($i &lt; $count &amp;&amp; $chars[$i] == $currentChar) &#123; $i++; $n++; &#125; $chars[$index++] = $currentChar; if ($n == 1) &#123; continue; &#125; $nStr = (string) $n; $nLen = strlen($nStr); for ($j = 0; $j &lt; $nLen; $j++) &#123; $chars[$index++] = $nStr[$j]; &#125; &#125; return $index;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode20. 有效的括号]]></title>
    <url>%2F2018%2F08%2F05%2Fvalid-parentheses%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/valid-parentheses Code1234567891011121314151617181920212223242526272829303132function isValidParentheses(string $str) :bool &#123; $stack = new SplStack(); $length = strlen($str); $leftBrackets = [ &apos;(&apos; =&gt; 1, &apos;&#123;&apos; =&gt; 2, &apos;[&apos; =&gt; 3, ]; $rightBrackets = [ &apos;)&apos; =&gt; 1, &apos;&#125;&apos; =&gt; 2, &apos;]&apos; =&gt; 3, ]; for ($i = 0; $i &lt; $length; $i++) &#123; if (isset($leftBrackets[$str[$i]])) &#123; $stack-&gt;push($str[$i]); &#125; elseif (isset($rightBrackets[$str[$i]])) &#123; if ($stack-&gt;isEmpty()) &#123; return false; &#125; $leftBracket = $stack-&gt;pop(); if ($leftBrackets[$leftBracket] != $rightBrackets[$str[$i]]) &#123; return false; &#125; &#125; &#125; return $stack-&gt;isEmpty();&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode125. 验证回文串]]></title>
    <url>%2F2018%2F08%2F05%2Fvalid-palindrome%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/valid-palindrome Code123456789101112131415161718192021222324252627282930313233343536373839function isPalindrome(string $str) :bool &#123; $length = strlen($str); if ($length == 0) &#123; return true; &#125; $i = 0; $j = $length - 1; $str = strtolower($str); while ($i &lt;= $j) &#123; while ($i &lt;= $j &amp;&amp; !isNumericOrLetter($str[$i])) &#123; $i++; &#125; while ($i &lt;= $j &amp;&amp; !isNumericOrLetter($str[$j])) &#123; $j--; &#125; if ($str[$i] != $str[$j]) &#123; return false; &#125; $i++; $j--; &#125; return true;&#125;function isNumericOrLetter(string $char) :bool &#123; if ((ord($char) &lt;= ord(&apos;9&apos;) &amp;&amp; ord($char) &gt;= ord(&apos;0&apos;)) || (ord($char) &lt;= ord(&apos;z&apos;) &amp;&amp; ord($char) &gt;= ord(&apos;a&apos;))) &#123; return true; &#125; return false;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode28. 实现strStr()]]></title>
    <url>%2F2018%2F08%2F04%2Fimplement-strstr%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/implement-strstr Code123456789101112131415161718192021222324252627function strStrN(string $haystack, string $needle) :int &#123; $lengthNeedle = strlen($needle); if ($lengthNeedle == 0) &#123; return 0; &#125; $lengthHaystack = strlen($haystack); $i = $j = 0; while ($i &lt;= $lengthHaystack - $lengthNeedle) &#123; for ($j = $lengthNeedle - 1; $j &gt;= 0; $j--) &#123; if ($haystack[$i + $j] != $needle[$j]) &#123; break; &#125; &#125; if ($j == -1) &#123; return $i; &#125; $i++; &#125; return -1;&#125; 类似于PHP中strpos函数，可以使用KMP算法、BM算法来解决。]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode345. 反转字符串中的元音字母]]></title>
    <url>%2F2018%2F08%2F02%2Freverse-vowels-of-a-string%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/reverse-vowels-of-a-string Code1234567891011121314151617181920212223242526272829303132function reverseVowels(string $str) :string &#123; $vowels = [ &apos;A&apos; =&gt; 1, &apos;a&apos; =&gt; 1, &apos;E&apos; =&gt; 1, &apos;e&apos; =&gt; 1, &apos;I&apos; =&gt; 1, &apos;i&apos; =&gt; 1, &apos;O&apos; =&gt; 1, &apos;o&apos; =&gt; 1, &apos;U&apos; =&gt; 1, &apos;u&apos; =&gt; 1, ]; $i = 0; $j = strlen($str) - 1; while ($i &lt; $j) &#123; while ($i &lt; $j &amp;&amp; !isset($vowels[$str[$i]])) &#123; $i++; &#125; while ($i &lt; $j &amp;&amp; !isset($vowels[$str[$j]])) &#123; $j--; &#125; list($str[$i], $str[$j]) = [$str[$j], $str[$i]]; $i++; $j--; &#125; return $str;&#125; 解释标准双指针解法]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode67. 二进制求和]]></title>
    <url>%2F2018%2F08%2F02%2Fadd-binary%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/add-binary Code1234567891011121314151617181920212223242526function addBinary(string $a, string $b, int $n = 2) :string &#123; $i = strlen($a) - 1; $j = strlen($b) - 1; $result = &apos;&apos;; $carry = 0; while ($i &gt;= 0 || $j &gt;= 0) &#123; $sum = $carry; if ($i &gt;= 0) &#123; $sum += $a[$i--]; &#125; if ($j &gt;= 0) &#123; $sum += $b[$j--]; &#125; $result = ($sum % $n) . $result; $carry = intdiv($sum, $n); &#125; if ($carry != 0) &#123; $result = $carry . $result; &#125; return $result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode788. 旋转数字]]></title>
    <url>%2F2018%2F08%2F01%2Frotated-digits%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/rotated-digits Code11234567891011121314151617181920212223242526272829function rotatedDigits(int $n) :int &#123; $result = 0; for ($i = 1; $i &lt;= $n; $i++) &#123; if (isValid($i)) &#123; $result++; &#125; &#125; return $result;&#125;function isValid(int $n) :bool &#123; $valid = false; while ($n &gt; 0) &#123; if ($n % 10 == 2 || $n % 10 == 5 || $n % 10 == 6 || $n % 10 == 9) &#123; $valid = true; &#125; if ($n % 10 == 3 || $n % 10 == 4 || $n % 10 == 7) &#123; return false; &#125; $n = intdiv($n, 10); &#125; return $valid;&#125; Code212345678910111213141516171819202122232425262728function rotatedDigits(int $n) :int &#123; $result = 0; $dp = array_fill(0, $n + 1, 0); // $dp[$i]=0，无效；$dp[$i]=1，有效，旋转后相等；$dp[$i]=2，有效，旋转后不相等； for ($i = 0; $i &lt;= $n; $i++) &#123; if ($i &lt; 10) &#123; if ($i == 0 || $i == 1 || $i == 8) &#123; $dp[$i] = 1; &#125; elseif ($i == 2 || $i == 5 || $i == 6 || $i == 9) &#123; $dp[$i] = 2; $result++; &#125; &#125; else &#123; $a = $dp[intdiv($i, 10)]; $b = $dp[$i % 10]; if ($a == 1 &amp;&amp; $b == 1) &#123; $dp[$i] = 1; &#125; elseif ($a &gt;= 1 &amp;&amp; $b &gt;= 1) &#123; $dp[$i] = 2; $result++; &#125; &#125; &#125; return $result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode696. 计数二进制子串]]></title>
    <url>%2F2018%2F08%2F01%2Fcount-binary-substrings%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/count-binary-substrings Code1234567891011121314151617181920function countBinarySubstrings(string $str) :int &#123; $length = strlen($str); $result = 0; $preCount = $curCount = 1; for ($i = 1; $i &lt; $length; $i++) &#123; if ($str[$i] != $str[$i - 1]) &#123; $preCount = $curCount; $curCount = 1; &#125; else &#123; $curCount++; &#125; if ($preCount &gt;= $curCount) &#123; $result++; &#125; &#125; return $result;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode13. 罗马数字转整数]]></title>
    <url>%2F2018%2F08%2F01%2Froman-to-integer%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/roman-to-integer Code1234567891011121314151617181920212223242526272829function romanToInt(string $str) :int &#123; $map = [ &apos;I&apos; =&gt; 1, &apos;V&apos; =&gt; 5, &apos;X&apos; =&gt; 10, &apos;L&apos; =&gt; 50, &apos;C&apos; =&gt; 100, &apos;D&apos; =&gt; 500, &apos;M&apos; =&gt; 1000 ]; $length = strlen($str); if ($length == 0) &#123; return 0; &#125; $sum = $map[$str[$length - 1]]; for ($i = $length - 2; $i &gt;= 0; $i--) &#123; if ($map[$str[$i]] &lt; $map[$str[$i + 1]]) &#123; $sum -= $map[$str[$i]]; &#125; else &#123; $sum += $map[$str[$i]]; &#125; &#125; return $sum;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode557. 反转字符串中的单词III]]></title>
    <url>%2F2018%2F08%2F01%2Freverse-words-in-a-string-iii%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/reverse-words-in-a-string-iii Code12345678910111213141516171819202122232425function reverseWords(string $str) :string &#123; $length = strlen($str); $start = 0; for ($i = 0; $i &lt;= $length; $i++) &#123; if ($i == $length || $str[$i] == &apos; &apos;) &#123; $str = doReverse($str, $start, $i - 1); $start = $i + 1; &#125; &#125; return $str;&#125;function doReverse(string $str, int $start, int $end) :string &#123; while ($start &lt; $end) &#123; $temp = $str[$start]; $str[$start] = $str[$end]; $str[$end] = $temp; $start++; $end--; &#125; return $str;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode344. 反转字符串]]></title>
    <url>%2F2018%2F08%2F01%2Freverse-string%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/reverse-string Code1234567891011121314function reverseString(string $str) :string &#123; $i = 0; $j = strlen($str) - 1; while ($i &lt; $j) &#123; $temp = $str[$i]; $str[$i] = $str[$j]; $str[$j] = $temp; $i++; $j--; &#125; return $str;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode657. 判断路线成圈]]></title>
    <url>%2F2018%2F07%2F31%2Fjudge-route-circle%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/judge-route-circle Code1234567891011121314151617181920function judgeCircle(string $moves) :bool &#123; $length = strlen($moves); $x = $y = 0; for ($i = 0; $i &lt; $length; $i++) &#123; if ($moves[$i] == &apos;U&apos;) &#123; $y++; &#125; elseif ($moves[$i] == &apos;D&apos;) &#123; $y--; &#125; elseif ($moves[$i] == &apos;R&apos;) &#123; $x++; &#125; elseif ($moves[$i] == &apos;L&apos;) &#123; $x--; &#125; else &#123; continue; &#125; &#125; return $x == 0 &amp;&amp; $y == 0;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode709. 转换为小写字母]]></title>
    <url>%2F2018%2F07%2F31%2Fto-lower-case%2F</url>
    <content type="text"><![CDATA[题目地址https://leetcode.com/problems/to-lower-case/description/ Code1234567891011function toLowerCase(string $str) :string &#123; $length = strlen($str); for ($i = 0; $i &lt; $length; $i++) &#123; if (ord(&apos;A&apos;) &lt;= ord($str[$i]) &amp;&amp; ord($str[$i]) &lt;= ord(&apos;Z&apos;)) &#123; $str[$i] = chr(ord($str[$i]) - ord(&apos;A&apos;) + ord(&apos;a&apos;)); &#125; &#125; return $str;&#125;]]></content>
      <categories>
        <category>leetcode</category>
        <category>string</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
